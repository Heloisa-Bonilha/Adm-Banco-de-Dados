USE ESQUINA_VENDAS

-- APERTAR O BOTÃO 'INCLUIR PLANO DE EXECUÇÃO REAL' (Ctrl + M) 
-- PARA VERMOS O QUE ACONTECE NA NOSSA CONSULTA

-- SELECT SEM INDICE
INSERT INTO TEST_INDICE2 (VALOR) VALUES ('10001')

SELECT * FROM TEST_INDICE2
WHERE VALOR = '10001'

-- SELECT COM INDICE
INSERT INTO TEST_INDICE1(VALOR) VALUES ('10001')

SELECT * FROM TEST_INDICE1
WHERE VALOR = '10001'

-- LEMBRE DE APERTAR O BOTÃO 'INCLUIR PLANO DE EXECUÇÃO REAL' (Ctrl + M) 
-- E AO FAZER A CONSULTA TERÁ UMA ABA DE PLANO DE EXECUÇÃO

SELECT C.CPF, C.NOME, NF.DATA, SUM(INF.QUANTIDADE) FROM [TABELA DE CLIENTES] C
INNER JOIN [TABELA DE NOTAS FISCAIS] NF
ON C.CPF = NF.CPF
INNER JOIN [TABELA DE ITENS NOTAS FISCAIS] INF
ON INF.NUMERO = NF.NUMERO
GROUP BY C.CPF, C.NOME, NF.DATA

-- EXEMPLOS
--CRIANDO TABELAS E PREENCHENDO AUTOMATICAMENTE PARA ANÁLISES DE CONSULTA
CREATE TABLE TABELA_HEAP
(
	A INT NOT NULL,
	B INT NOT NULL,  
	C INT NOT NULL,
	D INT NOT NULL,
	E INT NOT NULL,
	F INT NOT NULL,
)

-- VIEW NUM ALEATÓRIO
CREATE VIEW VW_ALEATORIO
AS
	SELECT RAND() AS 'VALOR ALEATORIO'

SELECT * FROM VW_ALEATORIO

-- FUNÇÃO NUM ALEATÓRIO EM UM RANGE
CREATE FUNCTION NumeroAleatorio (@VALOR_INIC INT, @VALOR_FINAL INT) RETURNS INT
AS
	BEGIN
		DECLARE @ALEATORIO INT
		DECLARE @ALEATORIA_FLOAT FLOAT
		SELECT @ALEATORIA_FLOAT = [VALOR ALEATORIO] FROM VW_ALEATORIO --CHAMANDO A VIEW PARA USAR A RAND()
		SELECT @ALEATORIO = ROUND (((@VALOR_FINAL - @VALOR_INIC) * @ALEATORIA_FLOAT + @VALOR_INIC),0)  --GERANDO O NÚMERO ALEATÓRIO
		--SELECT @ALEATORIO = ROUND (((500 - 100) * RAND() + 100),0)  --USO DE RAND() DENTRO DA FUNCTION NÃO PERMITIDO
		RETURN @ALEATORIO
	END


-- INSERT NA TABELA
INSERT INTO TABELA_HEAP (A,B,C,D,E,F) 
VALUES ([dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100))
GO 10

-- CONSULTAS E ANALISES
SELECT * FROM TABELA_HEAP

SELECT B, C FROM TABELA_HEAP
WHERE B = 38 AND C = 86

-- CRIAÇÃO INDEX NON CLUSTERED
CREATE NONCLUSTERED INDEX IX_TABELA_HEAP ON TABELA_HEAP(A)

SELECT B FROM TABELA_HEAP
WHERE B = 38

SELECT A FROM TABELA_HEAP
WHERE A = 49

-- CRIAÇÃO DE INDEX COMPOSTOS
CREATE INDEX IX_TABELA_HEAP_BC ON TABELA_HEAP(B, C)

-- BUSCA POR INDEX
SELECT B, C FROM TABELA_HEAP
WHERE B = 38 AND C = 86

-- BUSCA POR SCAN
SELECT A FROM TABELA_HEAP
WHERE B = 38 AND C = 86

-- BUSCA POR SCAN
SELECT A, B FROM TABELA_HEAP
WHERE B = 38 AND C = 86


-- A UNICA DIFERENÇA DOS INDICES COMPOSTOS É QUE AQUI NA CHAVE BALANCEADA VAMOS DESCER PELO INDICE D
-- MAS NO ULTIMO NIVEL DA CHAVE BALANCEADA VAMOS TER E
CREATE INDEX IX_TABELA_HEAP_D ON TABELA_HEAP(D) INCLUDE (E)

-- SEEK
SELECT D, E FROM TABELA_HEAP
WHERE D = 68 AND E = 65

-- SEEK
SELECT E, D FROM TABELA_HEAP
WHERE D = 68 AND E = 65

-- SEEK
SELECT E FROM TABELA_HEAP
WHERE D = 68 AND E = 65

-- SCAN
SELECT A FROM TABELA_HEAP
WHERE D = 68 AND E = 65


-- VERIFICAR SE NÃO CRIOU 'F' REPETIDO NA FUNÇÃO NUM ALEATÓRIO
CREATE UNIQUE INDEX IX_TABELA_HEAP_F ON TABELA_HEAP(F)

-- SEEK
SELECT F FROM TABELA_HEAP
WHERE F = 71

-- SEEK E RID (PARECE COM CHAVE PRIMÁRIA)
SELECT A FROM TABELA_HEAP
WHERE F = 71

-- TABELA COM INDICES CLUSTERED
CREATE TABLE TABELA_CLUSTERIZADA
(
	A INT NOT NULL,
	B INT NOT NULL,  
	C INT NOT NULL,
	D INT NOT NULL,
	E INT NOT NULL,
	F INT NOT NULL,
)

INSERT INTO TABELA_CLUSTERIZADA(A,B,C,D,E,F) 
VALUES ([dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100))
GO 10

-- VERIFICAR SE NÃO CRIOU 'A' REPETIDO NA FUNÇÃO NUM ALEATÓRIO
CREATE UNIQUE CLUSTERED INDEX IX_T_CLUSTERIZADA_A ON TABELA_CLUSTERIZADA (A)

SELECT * FROM TABELA_CLUSTERIZADA

-- CLUSTERED SCAN
SELECT A FROM TABELA_CLUSTERIZADA
WHERE B = 35 AND C = 12

-- INDICE CLUSTERIZADO
SELECT A FROM TABELA_CLUSTERIZADA
WHERE A = 13

-- POREM O SQL SERVER SEMPRE PROCURA O INDICE MAIS RÁPIDO
CREATE INDEX IX_T_CLUSTERIZADA_B ON TABELA_CLUSTERIZADA (B,C)

-- SEEK
SELECT B,C FROM TABELA_CLUSTERIZADA
WHERE B = 35 AND C = 12

CREATE INDEX IX_T_CLUSTERIZADA_D ON TABELA_CLUSTERIZADA (D) INCLUDE (E)

-- SEEK
SELECT D,E FROM TABELA_CLUSTERIZADA
WHERE D = 35 AND E = 12

CREATE UNIQUE INDEX IX_T_CLUSTERIZADA_F ON TABELA_CLUSTERIZADA (F)

-- SEEK E PESQUISA DE CHAVE
SELECT * FROM TABELA_CLUSTERIZADA
WHERE F = 1

SP_HELPINDEX TABELA_CLUSTERIZADA


-- JOINS

CREATE TABLE T_HEAP_A
(
	A INT NOT NULL,
	B INT NOT NULL,  
	C INT NOT NULL,
	D INT NOT NULL,
	E INT NOT NULL,
	F INT NOT NULL,
)

CREATE TABLE T_HEAP_B
(
	A INT NOT NULL,
	B INT NOT NULL,  
	C INT NOT NULL,
	D INT NOT NULL,
	E INT NOT NULL,
	F INT NOT NULL,
)

-- INSERT (POPULAR AS TABELAS)
INSERT INTO T_HEAP_A (A,B,C,D,E,F) 
VALUES ([dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100))
GO 10

INSERT INTO T_HEAP_B (A,B,C,D,E,F) 
VALUES ([dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100), [dbo].[NumeroAleatorio](1,100))
GO 10

-- HASH MATCH + SCAN A E B
SELECT A.A, B.B FROM T_HEAP_A A
INNER JOIN T_HEAP_B B
ON A.A = B.A

-- ANTES
CREATE INDEX IX_T_HEAP_A ON T_HEAP_A (A)
-- DEPOIS

-- SEEK E SCAN
SELECT A.A, B.B FROM T_HEAP_A A
INNER JOIN T_HEAP_B B
ON A.A = B.A

-- MITO: A ORDEM DOS JOINS AFETAM NA PERFORMANCE DA CONSULTA

SELECT C.CPF, C.NOME, NF.DATA, INF.QUANTIDADE FROM [TABELA DE CLIENTES] C
INNER JOIN [TABELA DE NOTAS FISCAIS] NF
ON C.CPF = NF.CPF
INNER JOIN [TABELA DE ITENS NOTAS FISCAIS] INF
ON INF.NUMERO = NF.NUMERO

SELECT C.CPF, C.NOME, NF.DATA, INF.QUANTIDADE FROM [TABELA DE ITENS NOTAS FISCAIS] INF
INNER JOIN [TABELA DE NOTAS FISCAIS] NF
ON INF.NUMERO = NF.NUMERO
INNER JOIN [TABELA DE CLIENTES] C
ON C.CPF = NF.CPF



-- CONSULTA PRA LÁ DE ESPECIAL PRA VOCES
-- TRAZ SUGESTÃO DE CRIAÇÃO DE INDICES EM TABELAS HEAP
SELECT
    sys.objects.name,
    (avg_total_user_cost * avg_user_impact) * (user_seeks + user_scans) AS Impact,
    'CREATE NONCLUSTERED INDEX ix_IndexName ON ' + sys.objects.name COLLATE DATABASE_DEFAULT + ' ( ' + ISNULL(mid.equality_columns, '') + CASE
        WHEN mid.inequality_columns IS NULL THEN ''
        ELSE CASE
                WHEN mid.equality_columns IS NULL THEN ''
                ELSE ','
            END + mid.inequality_columns
    END + ' ) ' + CASE
        WHEN mid.included_columns IS NULL THEN ''
        ELSE 'INCLUDE (' + mid.included_columns + ')'
    END + ';' AS CreateIndexStatement,
    mid.equality_columns,
    mid.inequality_columns,
    mid.included_columns
FROM sys.dm_db_missing_index_group_stats AS migs
INNER JOIN sys.dm_db_missing_index_groups AS mig
    ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details AS mid
    ON mig.index_handle = mid.index_handle
    AND mid.database_id = DB_ID()
INNER JOIN sys.objects WITH (NOLOCK)
    ON mid.OBJECT_ID = sys.objects.OBJECT_ID
WHERE (
    migs.group_handle IN (
        SELECT TOP (500) group_handle
        FROM sys.dm_db_missing_index_group_stats WITH (NOLOCK)
        ORDER BY (avg_total_user_cost * avg_user_impact) * (user_seeks + user_scans) DESC
    )
)
AND OBJECTPROPERTY(sys.objects.OBJECT_ID, 'isusertable') = 1
ORDER BY 2 DESC, 3 DESC


--MOSTRA OS INDICES QUE NAO ESTAO SENDO USADOS 
	SELECT o.name, indexname=i.name, i.index_id 
, reads=user_seeks + user_scans + user_lookups 
, writes = user_updates 
, rows = (SELECT SUM(p.rows) FROM sys.partitions p WHERE p.index_id = s.index_id AND s.object_id = p.object_id)
, CASE
 WHEN s.user_updates < 1 THEN 100
 ELSE 1.00 * (s.user_seeks + s.user_scans + s.user_lookups) / s.user_updates
 END AS reads_per_write
, 'DROP INDEX ' + QUOTENAME(i.name) 
+ ' ON ' + QUOTENAME(c.name) + '.' + QUOTENAME(OBJECT_NAME(s.object_id)) as 'drop statement'
FROM sys.dm_db_index_usage_stats s 
INNER JOIN sys.indexes i ON i.index_id = s.index_id AND s.object_id = i.object_id 
INNER JOIN sys.objects o on s.object_id = o.object_id
INNER JOIN sys.schemas c on o.schema_id = c.schema_id
WHERE OBJECTPROPERTY(s.object_id,'IsUserTable') = 1
AND s.database_id = DB_ID() 
AND i.type_desc = 'nonclustered'
AND i.is_primary_key = 0
AND i.is_unique_constraint = 0
AND (SELECT SUM(p.rows) FROM sys.partitions p WHERE p.index_id = s.index_id AND s.object_id = p.object_id) > 10000
ORDER BY reads



